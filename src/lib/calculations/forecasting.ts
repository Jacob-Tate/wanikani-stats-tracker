// Forecasting and Projection Calculations
import { addHours, addDays, addMonths, differenceInDays } from 'date-fns'
import type { Assignment, LevelProgression } from '@/lib/api/types'
import { calculateActiveAverage } from './activity-analysis'

export interface ReviewForecast {
  current: number
  next2h: number
  next6h: number
  next12h: number
  next24h: number
  peak: {
    time: Date
    count: number
  }
  hourlyBreakdown: Array<{
    time: Date
    count: number
  }>
}

export interface Level60Projection {
  expected: Date
  expectedActive: Date // NEW: projection using active average
  fastTrack: Date
  conservative: Date
  averageDaysPerLevel: number
  activeDaysPerLevel: number // NEW: active average
  medianDaysPerLevel: number
  fastestLevel: {
    level: number
    days: number
  }
  slowestLevel: {
    level: number
    days: number
  }
  excludedLevels: Array<{
    // NEW: transparency
    level: number
    days: number
    reason: string
  }>
}

/**
 * Calculate review forecast from assignments data
 */
export function calculateReviewForecast(assignments: Assignment[]): ReviewForecast {
  const now = new Date()

  // Count reviews by availability
  let current = 0
  let next2h = 0
  let next6h = 0
  let next12h = 0
  let next24h = 0

  // Also track by hour for visualization
  const reviewsByHour = new Map<number, number>()

  for (const assignment of assignments) {
    // Skip if hidden from reviews or not ready
    if (assignment.hidden) continue // Hidden items don't appear in review queue
    if (!assignment.available_at) continue
    if (assignment.srs_stage === 0) continue // Not unlocked
    if (assignment.srs_stage === 9) continue // Burned

    const availableAt = new Date(assignment.available_at)
    const msFromNow = availableAt.getTime() - now.getTime()
    const hoursFromNow = msFromNow / (1000 * 60 * 60)

    // Count cumulative totals based on actual availability time
    if (msFromNow <= 0) {
      // Already available
      current += 1
      next2h += 1
      next6h += 1
      next12h += 1
      next24h += 1
    } else if (hoursFromNow < 2) {
      next2h += 1
      next6h += 1
      next12h += 1
      next24h += 1
    } else if (hoursFromNow < 6) {
      next6h += 1
      next12h += 1
      next24h += 1
    } else if (hoursFromNow < 12) {
      next12h += 1
      next24h += 1
    } else if (hoursFromNow < 24) {
      next24h += 1
    }

    // For visualization, bucket by hour
    const hourBucket = msFromNow <= 0 ? 0 : Math.floor(hoursFromNow)
    if (hourBucket < 24) {
      const currentCount = reviewsByHour.get(hourBucket) || 0
      reviewsByHour.set(hourBucket, currentCount + 1)
    }
  }

  // Find peak hour
  let peakHour = 0
  let peakCount = 0
  reviewsByHour.forEach((count, hour) => {
    if (count > peakCount) {
      peakCount = count
      peakHour = hour
    }
  })

  // Create hourly breakdown
  const hourlyBreakdown = Array.from({ length: 24 }, (_, i) => ({
    time: addHours(now, i),
    count: reviewsByHour.get(i) || 0,
  }))

  return {
    current,
    next2h,
    next6h,
    next12h,
    next24h,
    peak: {
      time: addHours(now, peakHour),
      count: peakCount,
    },
    hourlyBreakdown,
  }
}

/**
 * Project date to reach level 60 based on historical pace
 */
export function projectLevel60Date(
  currentLevel: number,
  levelProgressions: LevelProgression[],
  averagingMethod: 'trimmed_mean' | 'median' = 'trimmed_mean',
  useCustomThreshold: boolean = false,
  customThresholdDays: number = 60
): Level60Projection {
  if (currentLevel >= 60) {
    // Already at max level
    return {
      expected: new Date(),
      expectedActive: new Date(),
      fastTrack: new Date(),
      conservative: new Date(),
      averageDaysPerLevel: 0,
      activeDaysPerLevel: 0,
      medianDaysPerLevel: 0,
      fastestLevel: { level: 60, days: 0 },
      slowestLevel: { level: 60, days: 0 },
      excludedLevels: [],
    }
  }

  // Calculate days into current level
  const now = new Date()
  const currentLevelProgression = levelProgressions.find(p => p.level === currentLevel)
  const daysIntoCurrentLevel = currentLevelProgression?.unlocked_at
    ? Math.max(0, differenceInDays(now, new Date(currentLevelProgression.unlocked_at)))
    : 0

  // Calculate days per level for completed levels
  const levelDurations: Array<{ level: number; days: number }> = []

  for (const progression of levelProgressions) {
    if (progression.passed_at && progression.unlocked_at) {
      const unlockedDate = new Date(progression.unlocked_at)
      const passedDate = new Date(progression.passed_at)
      const days = differenceInDays(passedDate, unlockedDate)

      if (days >= 0) {
        levelDurations.push({
          level: progression.level,
          days,
        })
      }
    }
  }

  if (levelDurations.length === 0) {
    // No historical data, use default estimates
    const now = new Date()
    return {
      expected: addMonths(now, (60 - currentLevel) * 0.4), // ~12 days/level
      expectedActive: addMonths(now, (60 - currentLevel) * 0.4), // ~12 days/level
      fastTrack: addMonths(now, (60 - currentLevel) * 0.27), // ~8 days/level
      conservative: addMonths(now, (60 - currentLevel) * 0.6), // ~18 days/level
      averageDaysPerLevel: 12,
      activeDaysPerLevel: 12,
      medianDaysPerLevel: 12,
      fastestLevel: { level: currentLevel, days: 8 },
      slowestLevel: { level: currentLevel, days: 18 },
      excludedLevels: [],
    }
  }

  // Calculate average days per level
  const totalDays = levelDurations.reduce((sum, item) => sum + item.days, 0)
  const averageDaysPerLevel = totalDays / levelDurations.length

  // Calculate active average (excluding breaks) using specified method and threshold
  const activeResult = calculateActiveAverage(
    levelProgressions,
    {
      absoluteThreshold: customThresholdDays,
      useCustomThreshold: useCustomThreshold,
    },
    averagingMethod
  )

  // Calculate median
  const sortedDurations = [...levelDurations].sort((a, b) => a.days - b.days)
  const medianDaysPerLevel =
    sortedDurations[Math.floor(sortedDurations.length / 2)].days

  // Find fastest and slowest
  const fastestLevel = sortedDurations[0]
  const slowestLevel = sortedDurations[sortedDurations.length - 1]

  // Calculate projections accounting for current level progress
  const levelsRemaining = 60 - currentLevel

  // Use total average for "expected"
  const expectedDays = Math.round(averageDaysPerLevel * levelsRemaining) - daysIntoCurrentLevel
  const expected = addDays(now, Math.max(0, expectedDays))

  // Use active average for "expectedActive"
  const expectedActiveDays = Math.round(activeResult.activeAverage * levelsRemaining) - daysIntoCurrentLevel
  const expectedActive = addDays(now, Math.max(0, expectedActiveDays))

  // Fast track: 8 days per level (WK speed run pace)
  const fastTrackDays = (8 * levelsRemaining) - daysIntoCurrentLevel
  const fastTrack = addDays(now, Math.max(0, fastTrackDays))

  // Conservative: Use active average * 1.5
  const conservativePace = Math.max(activeResult.activeAverage * 1.5, 18)
  const conservativeDays = Math.round(conservativePace * levelsRemaining) - daysIntoCurrentLevel
  const conservative = addDays(now, Math.max(0, conservativeDays))

  return {
    expected,
    expectedActive,
    fastTrack,
    conservative,
    averageDaysPerLevel: Math.round(averageDaysPerLevel * 10) / 10,
    activeDaysPerLevel: activeResult.activeAverage,
    medianDaysPerLevel,
    fastestLevel,
    slowestLevel,
    excludedLevels: activeResult.excludedLevels,
  }
}

/**
 * Calculate milestone dates (levels 30, 40, 50, 60)
 */
export function calculateMilestones(
  currentLevel: number,
  averageDaysPerLevel: number
): Array<{ level: number; date: Date; status: 'completed' | 'upcoming' }> {
  const milestones = [30, 40, 50, 60]
  const now = new Date()

  return milestones.map((level) => {
    if (level <= currentLevel) {
      return {
        level,
        date: now,
        status: 'completed' as const,
      }
    } else {
      const levelsToGo = level - currentLevel
      const daysToGo = levelsToGo * averageDaysPerLevel
      return {
        level,
        date: addDays(now, Math.round(daysToGo)),
        status: 'upcoming' as const,
      }
    }
  })
}
